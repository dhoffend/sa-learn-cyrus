#!/usr/bin/env perl

################################################################################
## 
## sa-learn-cyrus is an application that collects spam and non-spam (ham)
## messages from Cryus IMAPd user mailbox folders and feeds them into sa-learn
## to train the bayes database of SpamAssassin.
## 
## This is a forked version of the original sa-learn-cyrus tool by
## Hans-Juergen Beie. It provides bugfixes and improvements and adds
## integration with Kolab.
## 
## Copyright (C) 2004-2011 Hans-Juergen Beie <hjb@pollux.franken.de>
## Copyright (C) 2020 Michael Roland <mi.roland@gmail.com>
## 
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <https://www.gnu.org/licenses/>.
## 
################################################################################

my $me = 'sa-learn-cyrus';
my $VERSION = '0.4.0';
my $lupdate = '2020-04-04';
my $author = 'hjb+MR';
my $header = "$me-$VERSION ($author -- $lupdate)";
my $basename = `basename $0`;
chomp($basename);

# -------------------------------------------------------------

use strict qw(vars);
use Getopt::Long;
use Pod::Usage;
use File::Spec;

# -------------------------------------------------------------

my $my_full_name = File::Spec->rel2abs($0);
my ($vol,$dir, $name) = File::Spec->splitpath($my_full_name);
my $my_path = File::Spec->catpath($vol, $dir);
$my_path =~ s/(.*)\/$/$1/;

# -------------------------------------------------------------
# Default configuration
our %conf = (
    # - base -
    'basename'                  => $basename,
    'pid'                       => $$,
    'me'                        => $me,
    'header'                    => $header,
    'config_file'               => '/etc/spamassassin/sa-learn-cyrus.conf',
    'my_full_name'              => $my_full_name,
    'my_path'                   => $my_path,
    'verbose'                   => 0,

    # [global]
    'global:verbose'            => 0,
    'global:simulate'           => 'no',
    'global:lock_file'          => "/var/lock/$me\.lock",
    'global:log_with_tag'       => 'yes',

    # [mailbox]
    'mailbox:include_list'      => '',
    'mailbox:include_regexp'    => '',
    'mailbox:exclude_list'      => '',
    'mailbox:exclude_regexp'    => '',
    'mailbox:spam_folder'       => 'Spam',
    'mailbox:remove_spam'       => 'no',
    'mailbox:ham_folder'        => 'NoSpam',
    'mailbox:remove_ham'        => 'no',

    # [sa]
    'sa:site_config_path'       => '/etc/spamassassin',
    'sa:prefs_file'             => '/etc/spamassassin/local.cf',
    'sa:learn_cmd'              => '/usr/bin/sa-learn',
    'sa:bayes_storage'          => 'berkely',
    'sa:bayes_path'             => '',
    'sa:tokens'                 => '_toks',
    'sa:fix_db_permissions'     => 'yes',
    'sa:user'                   => 'mail',
    'sa:group'                  => 'mail',
    'sa:sync_once'              => 'yes',
    'sa:virtual_config_dir'     => '',
    'sa:debug'                  => 'no',

    # [imap]
    'imap:base_dir'             => '/var/spool/cyrus/mail',
    'imap:initial_letter'       => 'yes',
    'imap:domains'              => '',    
    'imap:unixhierarchysep'     => 'yes',
    'imap:purge_cmd'            => '/usr/lib/cyrus/bin/ipurge',
    'imap:mbpath_cmd'           => '/usr/lib/cyrus/bin/mbpath',
    'imap:mbexamine_cmd'        => '/usr/lib/cyrus/bin/mbexamine',
    'imap:user'                 => 'cyrus',
    'imap:userprefix'           => 'user',
    'imap:domainprefix'         => 'domain',
    'imap:mbox_glob'            => '/[0-9]*.',

    # [kolab]
    'kolab:enable'              => 'no',
    'kolab:util_cmd'            => '/usr/sbin/kolab',
    'kolab:mblist_subcmd'       => 'list-mailboxes',
);

# -------------------------------------------------------------
# exit codes
our %EX = (
    'ex_OK'                => 0,
    'ex_NoMailboxesFound'  => 1,  # nothing to do
    'ex_SytaxError'        => -1, # cmd line error
    'ex_NoConfigFile'      => -2, # config_file not readable
    'ex_ConfigError'       => -3, # error in config_file
    'ex_ProcLocked'        => -6, # there is another sa-lean-cyrus running
    'ex_SAConfNotFound'    => -7, # SA configuration not found
    'ex_PermissionDenied'  => -8, # only root is allowed to execute this program
    'ex_LockFailed'        => -9, # lock file could not be created
);

$| = 1;                # flush output imediately

#
# parse cmd line
#
my $args = join(' ', @ARGV);
our %OPT = ();
Getopt::Long::Configure ("bundling");
unless ( GetOptions(\%OPT, 
                    'help|h', 'man', 'version|V', 'verbose|v=i', 
                    'config|c=s', 'simulate|s', 'sa-debug|d', 'imap-domains|D=s',
                    'man-manpage=i', 'man-html', 'man-text',
                    ) 
        ) {
    bye('ex_SyntaxError', "Error reading arguments: '$args', try --help for help");
}

my @user_names = @ARGV;

#
# check cmd options
#
if ( $OPT{'help'} ) {
    my $sections = "USAGE";
    pod2usage( { -message    => $header,
                 -exitval    => 0,  
                 -verbose    => 99,
                 -sections   => $sections,
                 #-noperldoc  => 1,
                 -output     => \*STDOUT
                }
    );  
    bye('ex_OK', '');
};

if ( $OPT{'man'} ) {
    my $sections = "NAME|USAGE|FUNCTION|DESCRIPTION|ARGUMENTS|OPTIONS|CONFIGURATION|FILES|SEE ALSO|PREREQUISITES|AUTHOR|COPYRIGHT AND LICENSE|DISCLAIMER|ACKNOWLEDGMENTS";
    pod2usage( { -exitval    => 0,  
                 -verbose    => 99,
                 -sections   => $sections,
                 -output     => \*STDOUT,
                }
    );  
    bye('ex_OK', '');
};

if ( $OPT{'version'} ) {
    print "$header\n";
    bye('ex_OK', '');
};

if ( $OPT{'man-manpage'} ) {
    make_manpage(\%conf, $OPT{'man-manpage'});
    bye('ex_OK', '');
};

if ( $OPT{'man-html'} ) {
    make_htmldoc(\%conf);
    bye('ex_OK', '');
};

if ( $OPT{'man-text'} ) {
    make_txtdoc(\%conf);
    bye('ex_OK', '');
};

if ( $OPT{'config'} ) {
    if ( -r $OPT{'config'} ) {
        $conf{'config_file'} = $OPT{'config'};
    } else {
        bye('ex_NoConfigFile', "Configuration file '$OPT{'config'}' not readable: $!");
    }
};

# verbosity
if ( $OPT{'verbose'} ) {
    $conf{'verbose'} = $OPT{'verbose'};
}

log_msg('notice', $header);

bye('ex_PermissionDenied', "Only root can run $me") unless ( $< == 0 );

read_config(\%conf) or bye('ex_ConfigError', "Error reading config file '$conf{config_file}'");

# verbosity
if ( $conf{'global:verbose'} and ( $conf{'global:verbose'} > $conf{'verbose'}) ) {
    $conf{'verbose'} = $conf{'global:verbose'};
}
log_msg('info', "Verbosity level: $conf{'verbose'}");

# check bayes_storage
$conf{'sa:bayes_storage'} = lc($conf{'sa:bayes_storage'});
unless ( $conf{'sa:bayes_storage'} =~ /^(berkely|sql)/ ) {
    bye('ex_ConfigError', "Unknown value of option bayes_storage = $conf{'sa:bayes_storage'}. Known values are 'berkely' and 'sql'.");
}

# mailboxes
if ( @user_names ) {
    $conf{'mailbox:include_list'} = join(' ', @user_names);
    # disable include/exclude settings from config file
    $conf{'mailbox:include_regexp'} = '';
    $conf{'mailbox:exclude_list'} = '';
    $conf{'mailbox:exclude_regexp'} = '';
}

# sa:debug
if ( $OPT{'sa-debug'} ) {
    $conf{'sa:debug'} = 'yes';
    log_msg('notice', "SA debug mode enabled");
}

if ( $OPT{'simulate'} ) {
    $conf{'global:simulate'} = 'yes';
}
my $simulate = ($conf{'global:simulate'} =~ /^[yY]/);
log_msg('notice', "Running in simulation mode") if ( $simulate );

# imap:domains
if ( $OPT{'imap-domains'} ) {
    $conf{'imap:domains'} = $OPT{'imap-domains'};
}
log_msg('notice', "Scanning mailboxes in domains '$conf{'imap:domains'}'") if ( $conf{'imap:domains'} ne '' );

# check if we are locked
if ( my $pid = we_are_locked() ) {
    bye('ex_ProcLocked', "There is another $me (pid = $pid) running.");
}

create_lock_file();

if ( $conf{'sa:virtual_config_dir'} and ($conf{'sa:fix_db_permissions'} =~ /^[yY]/) ) {
    log_msg('warn', 'virtual_config_dir is incompatible with fix_db_permissions. Automatically disabling fix_db_permissions.');
    $conf{'sa:fix_db_permissions'} = 'no';
}

# read SA configuraion
if ( ($conf{'sa:bayes_storage'} =~ /^berkely/) and ($conf{'sa:fix_db_permissions'} =~ /^[yY]/) and !$conf{'sa:bayes_path'} ) {
    read_sa_config() or bye('ex_SANotFound', "Check your configuration!");
}

my @mailboxes = find_mailboxes();
unless (scalar @mailboxes) {
    bye ('ex_NoMailboxesFound', "No matching mailboxes found. There's nothing to do for me.");
}

my $mails_learned = 0;	# total count of learned mails
foreach my $mbx (sort @mailboxes) {
    my ($domain, $user) = split(/:/, $mbx, 2);
    my $user_qualified = $user;
    if ( $domain ne '' ) {
        $user_qualified .= '@' . $domain;
    }
    log_msg('notice', "User '$user_qualified'");

    for my $learn ('spam' , 'ham') {
        my $learn_folder = $conf{'mailbox:' . $learn . '_folder'};
        my $learn_path = get_mailbox_folder_path($domain, $user, $learn_folder);
        
        if ( $learn_path and ( -d $learn_path ) ) {
            log_msg('notice', "  Learning $learn from folder '$learn_folder' in path '$learn_path'.");
            
            my $virtual_config_dir;
            if ( $conf{'sa:virtual_config_dir'} ) {
                $virtual_config_dir = $conf{'sa:virtual_config_dir'};
                $virtual_config_dir =~ s/%%/%/g;
                $virtual_config_dir =~ s/%l/$user/g;
                $virtual_config_dir =~ s/%d/$domain/g;
                $virtual_config_dir =~ s/%u/$user_qualified/g;
            }
            
            my $mbox_glob = $conf{'imap:mbox_glob'};
            
            my $mailbox_folder = get_imap_folder_name($domain, $user, $learn_folder);
            my $mbexamine_cmd = $conf{'imap:mbexamine_cmd'};
            my $mbexamine_output = `$mbexamine_cmd "$mailbox_folder"`;
            my ($number_of_messages) = $mbexamine_output =~ /Number of Messages:\s+(\d+)/;
            if ((defined $number_of_messages) and ($number_of_messages > 0)) {
	        log_msg('debug', "Number of Messages not purged so far: $number_of_messages");
                # sa-learn command parameters
                my $cmd = $conf{'sa:learn_cmd'};
                $cmd .= ' --' . $learn;
                $cmd .= ' --debug' if ( $conf{'sa:debug'} =~ /^[yY]/ );
                $cmd .= " --siteconfigpath='$conf{'sa:site_config_path'}'" if ( $conf{'sa:site_config_path'} );
                $cmd .= " --prefspath='$conf{'sa:prefs_file'}'" if ( $conf{'sa:prefs_file'} );
                $cmd .= ' --no-sync' if ( $conf{'sa:sync_once'} =~ /^[yY]/ );
                $cmd .= " --dbpath='$virtual_config_dir/bayes'" if ( $conf{'sa:virtual_config_dir'} and ($conf{'sa:bayes_storage'} =~ /^berkely/) );
                $cmd .= " --username='$user'" if ( $conf{'sa:virtual_config_dir'} );
                $cmd .= " '$learn_path$mbox_glob'";
                $cmd .= ' 2>&1';
    
                log_msg('debug', "  Executing '$cmd'");
                my $do_purge = 0;
                if ( $simulate ) {
                    log_msg('notice', "  Simulate: '$cmd'");
                    $do_purge = 1;
                    $mails_learned += 1;
                } elsif ( open(my $fh, "-|", $cmd) ) {
                    while (<$fh>) {
                        chomp;
                        my $line = $_;
                        log_msg('notice', "  sa-learn> $line");
                        if ( $line =~ /Learned\s+tokens\s+from\s+(\d+)\s+message/ ) {
                            $mails_learned += int($1);
                        }
                    }
                    close($fh);
                    if ( $? == 0 ) {
                        $do_purge = 1;
                    } else {
                        log_msg('error', "  Learning $learn using command '$cmd' failed: $?");
                    }
                } else {
                    log_msg('error', "  Failed to run sa:learn_cmd '$cmd': $!");
                }
                if ( $do_purge and ($conf{'mailbox:remove_' . $learn} =~ /^[yY]/) ) {
                    # delete learned mails
                    log_msg('notice', "  Purging learned $learn mails from folder '$learn_folder'");
                    purge_mailbox_folder($domain, $user, $learn_folder);
                }
            } elsif (not defined $number_of_messages) {
                log_msg('error', "  Failed to extract the number of messages for folder '$learn_folder'!");
            } else {
                log_msg('debug', "  No new messages in folder '$learn_folder' found!");
	    }
	}
    }
}

if ( ($conf{'sa:bayes_storage'} eq 'berkely') and ($conf{'sa:fix_db_permissions'} =~ /^[yY]/) ) {
    # set uid/gid of bayes tokens file
    # this may prevent permission problems for spamd
    my $tokens = $conf{'sa:bayes_path'} . $conf{'sa:tokens'};
    if ( -e $tokens ) {
        log_msg('info', "Tokens in '$tokens'");
        my $owner_group = "$conf{'sa:user'}:$conf{'sa:group'}";
        unless ( $owner_group eq ':' ) {
            # chmod user:group tokens-file
            log_msg('notice', "Changing ownership of '$tokens' to '$owner_group'");
            my $cmd = "chown $owner_group '$tokens'";
            $cmd .= ' 2>&1';
            log_msg('debug', "  Executing '$cmd'");
            if ( $simulate ) {
                log_msg('notice', "  Simulate: '$cmd'");
            } elsif ( open(my $fh, "-|", $cmd) ) {
                while (<$fh>) {
                    chomp;
                    log_msg('notice', "  chown> $_");
                }
                close($fh);
                if ( $? != 0 ) {
                    log_msg('error', "  Changing ownership of '$tokens' using command '$cmd' failed: $?");
                }
            } else {
                log_msg('error', "  Changing ownership of '$tokens' using command '$cmd' failed: open failed");
            }
        }
    } else {
        log_msg('info', "No tokens '$tokens' found.");
    }
}

if ( ($conf{'sa:sync_once'} =~ /^[yY]/) and $mails_learned ) {
    # sync database
    log_msg('info', "Synchronizing Bayes database...");
    my $cmd = $conf{'sa:learn_cmd'};
    $cmd .= " --debug" if ( $conf{'sa:debug'} =~ /^[yY]/ );
    $cmd .= " --sync";
    $cmd .= ' 2>&1';

    log_msg('debug', "  Executing '$cmd'");
    if ( $simulate ) {
        log_msg('notice', "  Simulate: '$cmd'");
    } elsif ( open(my $fh, "-|", $cmd) ) {
        while (<$fh>) {
            chomp;
            log_msg('notice', "  sa-learn> $_");
        }
        close($fh);
    } else {
        log_msg('error', "  Failed to run sa:learn_cmd '$cmd': $!");
    }
}

bye('ex_OK', 'done.');

#---------------------------------------------------------------
#
# terminate program
#
sub bye {
    my ($exit_code, $msg) = @_;
    my $err = - $EX{$exit_code};

    if ( $err > 0 ) {
        log_msg('error', "$msg") if $msg;
        log_msg('error', '*** aborted ***');
    } else {
        if ( $conf{'lock_created'} ) {
            log_msg('debug', "Removing lock file '$conf{'global:lock_file'}'");
            unlink($conf{'global:lock_file'});
        }
        log_msg('info', "$msg") if $msg;
    }
    exit $err;
}

#---------------------------------------------------------------
#
# log messages
#
sub log_msg {
    my ($level, $msg) = @_;

    my $log_with_tag = ( $conf{'global:log_with_tag'} =~ /^[yY]/ );
    my $label = '';
    if ( $log_with_tag ) {
        $label .= iso_dts() . ' ' . $conf{'me'} . '[' . $conf{'pid'} . ']';
    }
    if ( $level ne '' ) {
        $level = lc($level);
        $label .= " $level";
    }
    if ( $label ne '' ) {
        $label .= ": ";
    }
    if ( $level =~ /err|warn/ ) {
        warn "$label$msg\n";
    } else {
        if ( $conf{'verbose'} < 1 ) {
            return;
        } elsif ( $conf{'verbose'} < 2 ) {
            return if ( $level =~ /info|debug/ );
        } elsif ( $conf{'verbose'} < 3 ) {
            return if ( $level =~ /debug/ );
        }
        print "$label$msg\n";
    }
}


#---------------------------------------------------------------
#
# Convert time to date/time string (ISO-8601)
#
sub iso_dts {
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime;
    my $now = sprintf ("%04d-%02d-%02d %02d:%02d:%02d", $year+1900, $mon+1, $mday, $hour, $min, $sec);
    return $now;
}


#---------------------------------------------------------------
#
# Trim leading and trailing white space
#
sub trim {
    my ($string) = @_;

    $string =~ s/^\s+//;
    $string =~ s/\s+$//;
    return $string;
}


#---------------------------------------------------------------
#
# create lock file
#
sub create_lock_file {
     $conf{'lock_created'} = 0;
     return if ( $conf{'global:simulate'} eq 'yes' );
     log_msg('info', "Creating lock file '$conf{'global:lock_file'}'");
     open(my $fh, ">$conf{'global:lock_file'}") or bye('ex_LockFailed', "Cannot create lock file '$conf{'global:lock_file'}': $!");
     print $fh "$conf{'pid'}\n";
     close($fh);
     $conf{'lock_created'} = 1;
}


#---------------------------------------------------------------
#
# check if we are locked
#
sub we_are_locked {
    my $pid = '???';
    my $lock_file = $conf{'global:lock_file'};
    return undef unless ( -f $lock_file );
    
    # we are locked, get the pid ...
    if ( open(my $fh, $lock_file) ) {
        while (<$fh>) {
            chomp;
            $pid = $_;
            last if ( $pid ne '' );
        }
        close($fh);
    } else {
        log_msg('warn', "Cannot open lock file $lock_file: $!");
    }
    return $pid;
}


#---------------------------------------------------------------
#
# read config params from a Windows like ini file
#
# returns a hash of params if successfull, otherwhise returns undef
#
sub read_config {
    my ($config) = @_;

    my $conf_file = $config->{config_file};
    
    if ( open(my $fh, $conf_file) ) {
        log_msg('info', "Reading config file '$conf_file'");

        my $section = '';
        while (<$fh>) {
            chomp;
            my $line = trim($_);            # trim white space
            next if ( $line eq '' );        # ignore empty lines
            next if ( $line =~ /^[#;]/ );   # ignore comment lines

            my $sec = get_section($line);
            if ( $sec ) {
                # it's a section, something like '[foobar]'
                $section = $sec;
                log_msg('debug', "Parsing section [$section]");
            } elsif ( $section ne '' ) {
                # check for 'param = value' pairs
                if ( my ($param, $value) = get_param_value($line) ) {
                    # it's a line like 'param = value'
                    $value = unquote($value);
                    $config->{"$section:$param"} = $value;
                    log_msg('debug', "  Option '$section:$param' set to '$value'");
                }
            }
        }
        close($fh);
        return $config;
    } else {
        log_msg('error', "Cannot open config file '$conf_file': $!");
        return undef;
    }
}


#---------------------------------------------------------------
#
# Get a section name, something like '[foobar]'?
# Section names may contain alphanumerical characters including '_' and '-'.
#
sub get_section {
    my ($string) = @_;
    if ( $string =~ /^\[(.+)\]$/ ) {
        return trim($1);
    } else {
        return undef;
    }
}


#---------------------------------------------------------------
#
# Get a 'param = value' pair
#
sub get_param_value {
    my ($string) = @_;
    my ($param, $value) = split(/\s*=\s*/, $string, 2);
    #my ($param, $value) = split(/\s*=\s*/, $string);
    if ( $param and ($value ne '') ) {
        return ($param, $value);
    } else {
        return undef;
    }
}


#---------------------------------------------------------------
#
# unquote
#
sub unquote {
    my ($string) = @_;
    
    $string =~ s/^\'(.*)\'$/$1/;
    $string =~ s/^\"(.*)\"$/$1/;
    return $string;
}


#---------------------------------------------------------------
#
# read SA config
#
sub read_sa_config {
    my $conf_file = $conf{'sa:prefs_file'};
    open(my $fh, $conf_file) or bye('ex_SAConfNotFound', "Cannot open '$conf_file': $!");
    log_msg('info', "Reading SA config '$conf_file'");
    while (<$fh>) {
        chomp;
        my $line = trim($_);
        next if ( $line eq '' );
        next if ( $line =~ /^#/ );
        my ($param, $value) = split(/\s+/, $line);
        if ( $param eq 'bayes_path' ) {
            $conf{'sa:bayes_path'} = $value;
            log_msg('notice', "Bayes path is '$value'");
            last;
        }
    }
    close($fh);
    if ( $conf{'sa:bayes_path'} ) {
        return 1;
    } else {
        log_msg('warn', "'bayes_path' not found in SA's config '$conf_file'.");
        return 0;
    }
}


#---------------------------------------------------------------
#
# search mailboxes in imap spool or with Kolab
#
sub find_mailboxes {
    my @mailboxes;

    # use domains?
    my @domains = ('');
    if ( $conf{'imap:domains'} ne '' ) {
        @domains = split(/\s+/, $conf{'imap:domains'});
        log_msg('debug', "Domains to search in: '@domains'");
    }

    if ( $conf{'kolab:enable'} =~ /^[yY]/ ) {
        log_msg('info', "Searching for mailboxes with Kolab ...");

        foreach my $domain (sort @domains) {
            parse_mailbox_list_kolab($domain, \@mailboxes)
        }

    } else {
        log_msg('info', "Searching for mailboxes in path $conf{'imap:base_dir'} ...");

        foreach my $domain (sort @domains) {
            my $base_dir = $conf{'imap:base_dir'};
            $domain = lc($domain);
            if ( $domain ne '' ) {
                $base_dir .= '/' . $conf{'imap:domainprefix'};
                $base_dir .= '/' . substr($domain, 0, 1) if ( $conf{'imap:initial_letter'} =~ /^[yY]/ );
                $base_dir .= '/' . $domain;
                log_msg('debug', "  searching in domain '$domain', path is '$base_dir'");
                unless ( -d $base_dir ) {
                    log_msg('warn', "  no such directory '$base_dir'");
                    next;
                }
            } else {
                log_msg('debug', "  assuming flat hierarchy (no domains)");
            }
            if ( $conf{'imap:initial_letter'} =~ /^[yY]/ ) {
                for my $first_char ('a' .. 'z') {
                    my $path = $base_dir . '/' . $first_char . '/' . $conf{'imap:userprefix'};
                    log_msg('debug', "  searching in path '$path'");
                    next unless ( -d $path );
                    parse_mailbox_list_dir($path, $domain, \@mailboxes);
                }
            } else {
                my $path = $base_dir . '/' . $conf{'imap:userprefix'};
                parse_mailbox_list_dir($path, $domain, \@mailboxes);
            }
        }
    }
    
    my $cnt = scalar @mailboxes;
    log_msg('info', "$cnt mailboxes found.");
    return @mailboxes;
}



#---------------------------------------------------------------
#
# get qualified IMAP folder name
#
sub get_imap_folder_name {
    my ($domain, $user, $folder) = @_;
    
    my $imap_hierarchysep = '.';
    if ( $conf{'imap:unixhierarchysep'} =~ /^[yY]/ ) {
        $imap_hierarchysep = '/';
        $folder =~ s/\./\//g;
    }
    my $imap_mail_box = $conf{'imap:userprefix'} . $imap_hierarchysep . $user;
    if ( $folder ne '' ) {
        $imap_mail_box .= $imap_hierarchysep . $folder;
    }
    if ( $domain ne '' ) {
        $imap_mail_box .= '@' . $domain;
    }
    
    return $imap_mail_box;
}


#---------------------------------------------------------------
#
# get mailbox folder path
#
sub get_mailbox_folder_path {
    my ($domain, $user, $folder) = @_;
    
    my $imap_mail_box = get_imap_folder_name($domain, $user, $folder);
    
    my $mailbox_path = undef;
    
    # get mailbox path from Cyrus
    my $cmd = $conf{'imap:mbpath_cmd'};
    $cmd .= " '$imap_mail_box'";
    $cmd .= " 2>/dev/null";
    log_msg('debug', "  Executing '$cmd'");
    if ( open(my $fh, "-|", $cmd) ) {
        while (<$fh>) {
            chomp;
            $mailbox_path = $_;
            last if ( $mailbox_path ne '' );
        }
        close($fh);
    } else {
        log_msg('error', "  Failed to run imap:mbpath_cmd '$cmd': $!");
    }
    
    if ( $mailbox_path ) {
        log_msg('debug', "  Path for folder '$folder' of user '$user' in domain '$domain' is '$mailbox_path'");
        return $mailbox_path;
    } else {
        log_msg('error', "  Failed to get path for folder '$folder' of user '$user' in domain '$domain'");
        return undef;
    }
}


#---------------------------------------------------------------
#
# purge mailbox folder
#
sub purge_mailbox_folder {
    my ($domain, $user, $folder) = @_;
    
    my $imap_mail_box = get_imap_folder_name($domain, $user, $folder);
    
    # get mailbox path from Cyrus
    my $usercmd = $conf{'imap:purge_cmd'};
    $usercmd .= " -f -b 0 '$imap_mail_box'";
    my $cmd = "su $conf{'imap:user'} -c \"$usercmd\"";
    $cmd .= " 2>&1";
    log_msg('debug', "  Executing '$cmd'");
    if ( $simulate ) {
         log_msg('notice', "  Simulate: '$cmd'");
    } elsif ( open(my $fh, "-|", $cmd) ) {
        while (<$fh>) {
            chomp;
            log_msg('debug', "  ipurge> $_") unless /Permission denied/;
        }
        close($fh);
        if ( $? != 0 ) {
            log_msg('error', "  Purging messages from folder '$folder' using command '$cmd' failed: $?");
        }
    } else {
        log_msg('error', "  Failed to run imap:purge_cmd '$cmd': $!");
    }
}


#---------------------------------------------------------------
#
# parse mailbox list from Kolab
#
sub parse_mailbox_list_kolab {
    my ($domain, $mailboxes) = @_;
    
    my $imap_mail_box = get_imap_folder_name($domain, '%', '');
    my $imap_userprefix = $conf{'imap:userprefix'};
    
    # enumerate mailboxes from Kolab
    my $cmd = $conf{'kolab:util_cmd'};
    $cmd .= ' ' . $conf{'kolab:mblist_subcmd'};
    $cmd .= " '$imap_mail_box'";
    log_msg('debug', "  Executing '$cmd'");
    if ( open(my $fh, "-|", $cmd) ) {
        while (<$fh>) {
            chomp;
            my $user = $_;
            $user =~ s/^$imap_userprefix[\.\/]//;
            my ($username, $userdomain) = split(/@([^@]*)$/, $user);

            if ( is_user_included($userdomain, $username) ) {
                log_msg('info', "  found '$userdomain:$username'");
                push(@$mailboxes, "$userdomain:$username");
            }
        }
        close($fh);
    } else {
        log_msg('error', "  Failed to run kolab mailbox enumeration '$cmd': $!");
    }
    
    return $mailboxes;
}


#---------------------------------------------------------------
#
# parse mailbox directory
#
sub parse_mailbox_list_dir {
    my ($path, $domain, $mailboxes) = @_;
    
    # parse directory
    my @items;
    if ( opendir(DIR, $path) ) {
        @items = readdir(DIR);
        closedir(DIR);
    } else {
        log_msg('error', "  Cannot parse path '$path': $!");
        return undef;
    }
    
    # search for mailbox directories
    foreach my $username (sort @items) {
        next if ( $username =~ /^\.{1,2}$/) ;    # ignore '.' and '..' 
        next unless ( -d "$path/$username" );    # must be a directory
        
        if ( $conf{'imap:unixhierarchysep'} =~ /^[yY]/ ) {
            $username =~ s/\^/./g;
        }

        if ( is_user_included($domain, $username) ) {
            log_msg('info', "  found '$domain:$username'");
            push(@$mailboxes, "$domain:$username");
        }
    }
    
    return $mailboxes;
}

#---------------------------------------------------------------
#
# match user agains include and exclude lists
#
sub is_user_included {
    my ($domain, $user) = @_;
    
    my @include_list = split(/\s/, $conf{'mailbox:include_list'});
    my @exclude_list = split(/\s/, $conf{'mailbox:exclude_list'});
    my $include_regexp = $conf{'mailbox:include_regexp'};
    my $exclude_regexp = $conf{'mailbox:exclude_regexp'};
    
    if ( @include_list ) {
        # check ONLY include_list if not empty
        log_msg('debug', "  checking '$user\@$domain' with include_list '@include_list'");
        foreach my $name (@include_list) {
            if ( $name eq "$user\@$domain" ) {
                log_msg('debug', "  '$user\@$domain' matches include_list '@include_list'");
                return 1;
            } elsif ( $name eq $user ) {
                log_msg('debug', "  '$user' matches include_list '@include_list'");
                return 1;
            }
        }
        log_msg('debug', "  '$user\@$domain' does not match include_list '@include_list'");
        return 0;
    }
    
    if ( $include_regexp ne '' ) {
        # check include_regexp if not empty
        log_msg('debug', "  checking '$user\@$domain' with include_regexp '$include_regexp'");
        if ( "$user\@$domain" =~ /$include_regexp/ ) {
            log_msg('debug', "  '$user\@$domain', matches include_regexp '$include_regexp'");
        } elsif ( ($domain eq '') and ($user =~ /$include_regexp/) ) {
            log_msg('debug', "  '$user', matches include_regexp '$include_regexp'");
        } else {
            log_msg('debug', "  '$user\@$domain' does not match include_regexp '$include_regexp'");
            return 0;
        }
    } else {
        log_msg('info', "  include_regexp is empty, no users will be selected");
        return 0;
    }
    
    if ( @exclude_list ) {
        # check exclude_list if not empty
        log_msg('debug', "  checking '$user\@$domain' with exclude_list '@exclude_list'");
        foreach my $name (@exclude_list) {
            if ( $name eq "$user\@$domain" ) {
                log_msg('debug', "  ignored '$user\@$domain', matches exclude_list '@exclude_list'");
                return 0;
            } elsif ( $name eq $user ) {
                log_msg('debug', "  ignored '$user', matches exclude_list '@exclude_list'");
                return 0;
            }
        }
    }
    
    if ( $exclude_regexp ne '' ) {
        # check exclude_regexp if not empty
        log_msg('debug', "  checking '$user\@$domain' with exclude_regexp '$exclude_regexp'");
        if ( "$user\@$domain" =~ /$exclude_regexp/ ) {
            log_msg('debug', "  ignored '$user\@$domain', matches exclude_regexp '$exclude_regexp'");
            return 0;
        } elsif ( ($domain eq '') and ($user =~ /$exclude_regexp/) ) {
            log_msg('debug', "  ignored '$user', matches exclude_regexp '$exclude_regexp'");
            return 0;
        }
    }
    
    return 1;
}


#---------------------------------------------------------------
#
# make text doc
#
sub make_txtdoc {
    use Pod::Text;
    
    my ($conf) = @_;
    my $parser = Pod::Text->new (release => $conf->{'version'}, section => 8);
    $parser->parse_from_file($conf->{'my_full_name'});
}

#---------------------------------------------------------------
#
# make manpage
#
sub make_manpage {
    use Pod::Man;
    
    my ($conf, $section) = @_;
    my $parser = Pod::Man->new (release => $conf->{'version'}, section => $section);
    $parser->parse_from_file($conf->{'my_full_name'});
}

#---------------------------------------------------------------
#
# make html doc
#
sub make_htmldoc {
    use Pod::Html;

    my ($conf) = @_;
    my $tmp_dir = File::Spec->tmpdir();

    # seems only to work if current dir is the same as the source is locaated
    my $cur_dir = File::Spec->curdir();
    chdir($conf->{'my_path'});
    pod2html($conf->{'me'}, 
             "--title=$conf->{'header'}", 
             "--htmldir=$conf->{'my_path'}", 
             "--backlink", 
             '--index',
             "--cachedir=$tmp_dir",
             '--flush',
             "--infile=$conf->{'my_full_name'}"
            );
    chdir($cur_dir);
}


__END__

################################################################

=head1 NAME

sa-learn-cyrus - Train Spamassassin with spam/ham from user's imap mailboxes

=head1 USAGE

sa-learn-cyrus [ options ] user-name(s)

  user-name(s)              One ore more user/mailbox name(s).

  options:
    --help                  Prints a brief help message and exits.
    -h

    --man                   Prints the manual page and exits.

    --verbose level         Be verbose if level > 0
    -v level

    --config file           Use a configuration file other than the default
    -c file                 one.

    --sa-debug              Run sa-learn in debug mode.
    -d

    --simulate              Run in simulation mode (show commands only).
    -s

    --imap-domains domains  Search mailboxes in list of domains.
    -D domains

=head1 DESCRIPTION

B<sa-learn-cyrus> feeds spam and non-spam (ham) messages to Spamassassin's 
database. Its main purpose is to train SA's bayes database with spam/ham 
messages sorted by the mailbox owners into special subfolders.

It is intended to be used on smal mail systems (e.g. home office) with a 
single server-wide SA configuration.   

Launching B<sa-learn-cyrus> at regular intervalls (cron job) may improve SA's 
hit rate considerably, provided that the users are well instructed what to 
move to their ham/spam folders and what not.

=head1 FUNCTION

B<sa-learn-cyrus> scans local mail spools as used by Cyrus IMAPd for special 
subfolders. These subfolders are supposed to contain mails which have been 
classfied as spam or ham by the mailbox owners. 

Example: The users move spam mails which have not been tagged as spam by 
SpamAssassin (false positives) to a subfolder F<INBOX.Learn.Spam>. Other mails, 
which may be classified by SA as spam in the future because of certain 
characteristics are copied to a subfolder F<INBOX.Learn.Ham>.  

B<sa-learn-cyrus> feeds the content of these spam/ham folders to SA's Bayes 
database using the B<sa-learn> tool which is shipped with the Spamassassin 
package.

Afterwards these mails are deleted (optionally) by means of B<ipurge> which is 
a helper tool coming along with the Cyrus IMAPd package.

=head1 ARGUMENTS

B<sa-learn-cyrus> optionally takes a list of mailbox/user names as agruments:

  sa-learn-cyrus fred wilma fritz hjb

If not supplied all mailboxes found will be handled.

=head1 OPTIONS

All options supplied on the comand line will override corresponding parameters
given in the configuration file.

Please note that the basic parameters of sa-learn-cyrus have to be
defined in a configuration file. sa-learn-cyrus cannot be controlled solely by 
means of command.

=over 4

=item B<--config file, -c file>

Use configuration file other then the default one. 
Always adopt the configuartion file to your needs before using sa-learn-cyrus 
on a live system. Otherwise you may loose data or corrupt your SA data base!

=item B<--verbose level, -v level>

Specify level of verbosity. (Default = 0)

=item B<--sa-debug, -d>

Run sa-learn in debug mode. This may be useful to examine problems with 
sa-learn.

=item B<--simulate, -s>

Run B<sa-learn-cyrus> in simulation mode. This is useful for first tests after
initial configuration or if problem are encountered. In simulation mode 
B<sa-learn-cyrus> doesn't execute any system commands nor does it touch any 
data. It just displays what it would do.

=item B<--imap-domains list-of-domains, -D list-of-domains>

If your Cyrus installation uses the "domain support" you may use this option
to tell what domains you want to be searched.

  --domains example.com,another.org

is equivalent to 

  [imap]
  ...
  domains = example.com another.org 
  ...

in the configuration file.

=back

=head1 CONFIGURATION

By default B<sa-learn-cyrus> expects its configuration file as 
F</etc/sapmasassin/sa-learn-cyrus.conf>.

One has to change this setting in the code, if another default file is wanted.
Another than the default file can always be choosen with the C<--config option>. 

A sample configuration file is shipped with sa-learn-cyrus.

=head2 Format

The configuration file has a format as knwon from rsync or samba is very
similar to the format of Windows ini files. The file consist of sequence 
sections. The begin of each section is designated with a section name, a word 
in square brackets, e.g. C<[global]>. The section entries consist of 
parameters, which are key/value pairs each on a single line. Key an value are 
separated by an equal sign like

  key = value

The value is a single word or a list of words each of them representing a 
number or a string. Words may be surrounded ba any number of spaces for better 
readability. Empty lines and lines with a leading hash character C<#> are 
ingored.

=head2 Section [global]

The [global] section contains all global control parameters.

=over 4

=item B<lock_file = full-path-to-lock-file>

To avoid race conditions, B<sa-learn-cyrus> uses a simple file locking mechanism. 
Each new sa-learn-cyrus process looks for this file before it realy does 
anything. If this file exists, the process exits with a warning, assuming that 
another sa-learn-cyrus process is running.

=item B<verbose = level>

The level of verbosity. Values range from 0 (low) to 3 (high). A reasonable 
level to start with is 1.

=item B<simulate = yes|no>

B<sa-learn-cyrus> should be run in simulation mode (C<simulate = yes>) after the 
first customization of the configuration to avoid loss of data or corruption 
of SA's database in case of wrongly configured parameters. Defaults to C<no>.

=item B<log_with_tag = yes|no>

Prepend the ouput (log) with a tag (date, time, pid). Set to C<no>
to avoid additional tagging when piped to syslog. Defaults to C<yes>.

=back

=head2 Section [mailbox]

Section [mailbox] contains all parameters to select the mailboxes, to specify 
the special subfolders, and to define the actions to apply.

=over 4

=item B<include_list = list-of-mailboxes>

Only spam/ham mails of these mailboxes are fed to Spamassassin's database. If 
this list is empty, all mailboxes will be used. C<include_list> may be used 
instead of the list on the command line. If C<include_list> or a list of users
on the command line is used, C<exclude_list> and C<exclude_regexp> are ignored.
If IMAP domains are used, the user names provided in this list can be used to
match qualified user names (in the form 'username@domain') or unqualified user
names (in the form 'username'). The latter matches users across all domains.

Example:

  include_list = fred@domain1 wilma@domain2 fritz hjb

=item B<include_regexp = regular-expression>

If C<include_list> is empty, a regular expression given here is applied to all 
mailbox names to select mailboxes. If domains are used, the expression is
matched against the qualified user name. This parameter is ignored if
C<include_list> is not empty. If C<include_regexp> no user will be selected!

Example: Include all mailboxes beginning with 'knf-'.

  include_regexp = ^knf-

=item B<exclude_list = list-of-mailboxes>

If C<include_list> is empty, a list of mailboxes which will be excluded. This
list is applied to the results that pass C<include_regexp>. This
parameter is ignored if C<include_list> is not empty.

=item B<exclude_regexp = regular-expression>

If C<include_list> is empty, a regular expression given here is used to exclude
mailbox names from processing. This regular expression is applied to the results
that pass C<include_regexp> (if present) and C<exclude_list>. This parameter is
ignored if C<include_list> is not empty.

Example: Ignore all mailboxes for domain 'example.com'

  exclude_regexp = @example\.com$

=item B<spam_folder = folder-name>

The name of the special subfolder in each mailbox which contains spam. The name
should be a complete folder path relative to the root folder INBOX. The Cyrus 
nomenclature is applied (same as with cyradm).

Example: 

  spam_folder = Learn.Spam

This is a subfolder in a folder tree like this:

    INBOX
    +--Drafts
    +--Templates
    +--Sent
    +--Learn
    |  +--Ham
    |  +--Spam  <-- spam subfolder
    |

=item B<ham_folder = folder-name>

The name of the special subfolder in each mailbox which contains ham.
(Same naming scheme as with C<spam_folder>, see above.)

=item B<remove_spam = yes|no>

Remove the spam messages in the C<spam_folder> after feeding them into the SA
database. Defaults to C<no>.

=item B<remove_ham = yes|no>

Remove the ham messages in the C<ham_folder> after feeding them into the SA
database. Defaults to C<no>.

=back

=head2 Section [sa]

Spamassassin (SA) configuration parameters.

=over 4

=item B<site_config_path = path>

Path to system-wide SA preferences (defaults to F</etc/spamassassin>).

Example: 

  site_config_path = /etc/spamassassin

=item B<prefs_file = file>

Path of the system-wide SA configuration file (defaults to F</etc/spamassassin/local.cf>).

Example: 

  prefs_file = /etc/spamassassin/local.cf

=item B<learn_cmd = path>

Path to the sa-learn utility (defaults to F</usr/bin/sa-learn>).

Example:

  learn_cmd = /usr/bin/sa-learn

=item B<bayes_storage = berkely|sql>

Bayes storage mechanism (berkely|sql)

berkely: Berkely DB (default) 

sql: SQL Database

=item B<bayes_path = path>

Path to system-wide Bayes database. If empty (default), the path is obtained from
C<prefs_file>.

Example: 

  bayes_path = ~/.spamassassin/bayes

=item B<fix_db_permissions = yes|no>

Should permissions of DB files be fixed? Ignored unless C<bayes_storage = berkely>

=item B<user = user-id>

The user id SA runs with. Required if C<fix_db_permissions = yes>.

Example: 

  user = mail

=item B<group = group-id>

The group id SA runs with. Required if C<fix_db_permissions = yes>.

Example:

  group = mail

=item B<sync_once = yes|no>

Skip synchronization after every change of database, but sync once after all
messages have been learned. May speed up learning from many folders. Defaults
to C<yes>.

=item B<virtual_config_dir = pattern>

Use this if you use the C<--virtual-config-dir> option of C<spamd> (it needs
to match exactly). See the C<spamd> man page for more information.

=item B<debug = yes|no>

Run sa-learn in debug mode. C<debug = yes> may be useful to examine problems.
Defaults to C<no>.

=back

=head2 Section [imap]

The section [imap] contains the necessary configuration parameters to locate
and manage the (Cyrus) IMAPd spool files.

=over 4

=item B<base_dir = dir>

The base directory of the IMAP spool (below that the mailboxes are located).
Defaults to F</var/spool/cyrus/mail>. This setting is ignored if Kolab is used
to enumerate mailboxes.

=item B<initial_letter = yes|no>

If base_dir is divided in subdirectories named with the initial letters of 
mailbox names set C<initial_letter = yes> (default), otherwise choose C<no>.
This setting is ignored if Kolab is used to enumerate mailboxes.

Examples for joe's mailbox:

  <base_dir>/j/user/joe/ : initial_letter = yes
  <base_dir>/user/joe/ : initial_letter = no

=item B<domains = list-of-domains>

If your Cyrus spool uses domain hierarchy, only mailboxes from these domains
will be enumerated. If Kolab is used to enumerate mailboxes, you may leave
this field empty to enumerate mailboxes from all domains. If domain support
is not used, leave this entry empty.

The C<initial_letter> option (see above) is applied to domains, too.

Example for mailboxes fritz@bar.org and joe@foo.com:

The mail files within the Cyrus spool are located at

  <base_dir>/domain/b/bar.org/f/fritz
  <base_dir>/domain/f/foo.com/j/joe

List the domains as

  domains = foo.com bar.org

=item B<unixhierarchysep = yes|no>

Correspondes to the C<unixhierarchysep> in Cyrus C<imapd.conf>.

=item B<purge_cmd = path-to-command>

The path to the Cyrus B<ipurge> utility for purging mail messages. Defaults
to F</usr/lib/cyrus/bin/ipurge>.

Example:

  purge_cmd = /usr/lib/cyrus/bin/ipurge

=item B<mbpath_cmd = path-to-command>

The path to the Cyrus B<mbpath> utility for discovering the file system
path of mailboxes. Defaults to F</usr/lib/cyrus/bin/mbpath>.

Example:

  mbpath_cmd = /usr/lib/cyrus/bin/mbpath

=item B<user = user>

The user Cyrus-IMAPd runs as.

Example:

  user = cyrus

=back

=head2 Section [kolab]

The section [kolab] contains the necessary configuration parameters for
the Kolab integration.

=over 4

=item B<enable = yes|no>

Use Kolab to enumerate mailboxes. Defaults to C<no>.

=item B<util_cmd = path-to-command>

The path to the Kolab B<kolab> administration CLI utility. Defaults
to F</usr/sbin/kolab>.

Example:

  util_cmd = /usr/sbin/kolab

=item B<mblist_subcmd = path-to-command>

The sub-command of the Kolab administration CLI utility for enumerating
mailboxes. Defaults to C<list-mailboxes>.

Example:

  mblist_subcmd = list-mailboxes

=back

=head1 FILES

F</etc/spamassassin/sa-learn-cyrus.conf>

=head1 SEE ALSO

C<sa-learn(1)>, C<spamassassin(1)>, C<Mail::SpamAssassin(3)>, 
C<Mail::SpamAssassin::Conf(3)>, C<imapd(8)>, C<imapd.conf(5)>,
C<spamd(8)>

The current version of this application is available at
L<https://github.com/michaelroland/sa-learn-cyrus>

=head1 PREREQUISITES

B<sa-learn> (part of the SpamAssassin package), B<ipurge> (part of Cyrus IMAPd)

=head1 AUTHORS

=over

=item Hans-Juergen Beie E<lt>hjb@pollux.franken.deE<gt>

=item Michael Roland E<lt>mi.roland@gmail.comE<gt>

=back

=head1 COPYRIGHT AND LICENSE

=over

=item Copyright (c) 2004-2011 Hans-Juergen Beie

=item Copyright (c) 2020 Michael Roland

=back

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see L<https://www.gnu.org/licenses/>.

=head1 DISCLAIMER

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.

=head1 ACKNOWLEDGMENTS

Thanks to Robert Carnecky and Jan Hauke Rahm for testing and suggestions for
the implementation of the domain support. David Caldwell contributed the 
virtual_config_dir feature. Some other contributers are listed in the 
CHANGELOG. Many thanks to them for their help and suggestions.

=cut
